esphome:
  name: proto-3
  friendly_name: Proto 3

esp32:
  board: esp32dev
  framework:
    type: arduino

#deep_sleep:
#  id: sleepybaby
#  run_duration: 5min
#  sleep_duration: 5min

# Enable logging
logger:

# Enable Home Assistant API
api:
  encryption:
    key: "CAgTcJVmSBgNKcQWx8bSWqd2n1BVg14sOXXaxBVvrng="

ota:

web_server:
  port: 6969
  local: True

mqtt:
  broker: zackshouse.duckdns.org
  username: zack
  password: 
  topic_prefix: proto/proto-3
  on_connect:
    then:
      - component.update: led_matrix_32x16_display
  on_message:
#    - topic: proto/proto-4/binary_sensor/button/state
#      payload: 'ON'
#      then:
#        - light.turn_on:
#            id: partition_light_2
#            effect: WLED
#        - light.turn_on:
#            id: partition_light_3
#            effect: WLED
#        - light.turn_on:
#            id: partition_light_3
#            effect: WLED
    - topic: proto/proto-4/binary_sensor/button/state
      payload: "HELD"
      then:
        - light.turn_on:
            id: partition_light_2
            effect: WLED
    - topic: proto/proto-4/binary_sensor/button/state
      payload: "HELDLONG"
      then:
        - light.turn_off:
            id: partition_light_2 
        - delay: 1.2s
        - display.page.show: page1
        - component.update: led_matrix_32x16_display


# I wish
#        - lambda: |-
#            it.image(0, 0, id(megan), ImageAlign::TOP_LEFT);



wled:

time:
  - platform: sntp
    timezone: EST5EDT,M3.2.0,M11.1.0
    id: time_sntp

wifi:
  networks:
  - ssid: !secret wifi_ssid_mobile
    password: !secret wifi_password_mobile
  - ssid: !secret wifi_ssid
    password: !secret wifi_password
  - ssid: !secret wifi_ssid_megan
    password: !secret wifi_password_megan

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: "tell your WiFi said hi PROTO-3"
  
captive_portal:

font:
  - file: "arcade_r.ttf"
    id: font_large
    size: 7
    glyphs: "0123456789:APM."
  - file: "gfonts://Silkscreen@400"
    id: font_xl
    size: 32
  - file: "gfonts://Silkscreen@400"
    id: font_text
    size: 8

image:
  - file: mdi:cross
    id: icon_1
    resize: 4x4
  - file: mdi:arrow-left-thick
    id: icon_2
    resize: 8x8
#  - file: megan3-01-01.png
#    id: megan
#    resize: 16x32
#    type: RGB565
#  - file: kim.png
#    id: kim
#    resize: 32x16
#    type: RGB565



substitutions:
  lcd_width: '32'
  lcd_height: '16'
  scroll_speed: 1s

display:
  - platform: addressable_light
    id: led_matrix_32x16_display
    addressable_light_id: led_matrix_light
    width: 32
    height: 16
    pixel_mapper: |-
      int iMatrixOffset = y >= 8 ? 256 : 0;
      if (x % 2 == 0) {
        return (x * 8) + (y % 8) + iMatrixOffset;
      }
      return (x * 8) + iMatrixOffset + (7 - (y % 8));
    rotation: 0Â°
    update_interval: 60sec

    on_page_change:
      - from: page1
        to: page2
        then:
         - delay: 60s
         - display.page.show: page1
         - component.update: led_matrix_32x16_display

    pages:
      - id: page1
    
        lambda: |-

          auto text = Color(120, 0, 255);
          Color red = Color(150, 0, 0);
          Color green = Color(0x00FF00);
          Color blue = Color(0, 0, 90);
          Color white = Color(90, 90, 90);
          Color dark_red = Color(90, 0, 0);

          it.strftime(0, 0, id(font_large), text, TextAlign::TOP_LEFT, "%I", id(time_sntp).now());
          it.strftime(19, 0, id(font_large), text, TextAlign::TOP_LEFT, "%M", id(time_sntp).now());

          it.printf(0, 8, id(font_large), red, TextAlign::TOP_LEFT, "%s", id(inside_temp).state.c_str());
          it.printf(19, 8, id(font_large), red, TextAlign::TOP_LEFT, "%s", id(outside_temp).state.c_str());

          if (id(big_ac).state) {
            it.rectangle(26, 1, 5, 5, green);
          } else {
          }
          if (id(little_ac).state) {
            it.rectangle(27, 2, 3, 3, green);
          } else {
          }

      - id: page2
        lambda: |-
          auto text = Color(120, 0, 255);
          Color red = Color(150, 0, 0);
          Color green = Color(0x00FF00);
          Color blue = Color(0, 0, 90);
          Color white = Color(90, 90, 90);
          Color dark_red = Color(90, 0, 0);

          it.printf(-1, -2, id(font_text), red, TextAlign::TOP_LEFT, "%s", id(text_for_display).state.c_str());
          it.printf(-1, 4, id(font_text), red, TextAlign::TOP_LEFT, "%s", id(text_for_display2).state.c_str());

#          it.printf(0, 0, id(font_text), white, "-%f", id(text_for_display).state);
#          it.print(0, 0, id(font_text), text, TextAlign::TOP_LEFT, "hello");
output:
  - platform: ledc
    pin: GPIO4
    id: gpio_4
    channel: 2
    max_power: 20%

  - platform: ledc
    pin:
      number: GPIO33
      inverted: True
    id: gpio_33

light:
  - platform: monochromatic
    output: gpio_4
    name: LED
    id: led
    effects:
      - random:
          transition_length: 100ms
          update_interval: 100ms
      - flicker:
          alpha: 95%
          intensity: 10%
      - strobe:
      - pulse:
          transition_length: 4000ms
          update_interval: 4000ms     
        
  - platform: monochromatic
    output: gpio_33
    name: Red LED
    id: red_led
    effects:
      - random:
          transition_length: 100ms
          update_interval: 100ms
      - flicker:
          alpha: 95%
          intensity: 10%
      - strobe:
      - pulse:
          transition_length: 4000ms
          update_interval: 4000ms

  - platform: partition
    name: "Onboard LED"
    id: onboard_led
    segments:
      - single_light_id: led
    effects:
      - wled:
      - random:
          transition_length: 100ms
          update_interval: 100ms
      - flicker:
          alpha: 95%
          intensity: 10%
      - strobe:
      - pulse:
          transition_length: 4000ms
          update_interval: 4000ms  

  - platform: fastled_clockless
    chipset: WS2812B
    pin: GPIO12
    num_leds: 512
    rgb_order: GRB
    name: "led_matrix"
    id: led_matrix_light
    default_transition_length: 1s
    color_correct: [50%, 50%, 50%]
    restore_mode: ALWAYS_OFF
    effects:
      - addressable_twinkle:
      - addressable_twinkle:
          name: Big Twinkle
          twinkle_probability: 95%
          progress_interval: 4ms
      - addressable_rainbow:
      - addressable_rainbow:
          name: Rainbow Custom
          speed: 60
          width: 100
      - addressable_color_wipe:
      - addressable_color_wipe:
          name: Color Wipe Custom
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_scan:
      - addressable_scan:
          name: Scan Effect Custom 
          move_interval: 1ms
          scan_width: 8
      - addressable_random_twinkle:
      - addressable_random_twinkle:
          name: Random Twinkle Custom 
          twinkle_probability: 65%
          progress_interval: 32ms
      - addressable_fireworks:
      - addressable_fireworks:
          name: Fireworks Custom 
          update_interval: 32ms
          spark_probability: 10%
          use_random_color: false
          fade_out_rate: 120
      - addressable_flicker:
      - addressable_flicker:
          name: Flicker Custom 
          update_interval: 8ms
          intensity: 40%
      - addressable_lambda:
          name: New Fire
          update_interval: 70ms
          lambda: |-
            const bool colmajor = false;
            const bool mattop = true;
            const bool matleft = true;
            const bool zigzag = true;
            const uint16_t rows = 32;
            const uint16_t cols = 16;
            const uint16_t offsetx = 0;
            const uint16_t offsety = 0;
            const uint8_t maxflare = 3;
            const uint8_t flarerows = 7;
            const uint8_t flarechance = 30;
            const uint8_t flaredecay = 14;
            const uint32_t colors[] = {0x000000,0x100000,0x300000,0x600000,0x800000,0xA00000,0xC02000,0xC04000,0xC06000,0xC08000,0x807080};
            const uint8_t NCOLORS = (sizeof(colors)/sizeof(colors[0]));

            static uint8_t nflare = 0;
            static uint32_t flare[maxflare];
            static uint8_t pix[rows][cols];
            static bool needsinit = true;
            static long t = 0;
            
            uint16_t b, d, i, j, k, l, n, x, y, z;
            uint16_t phy_w = cols;
            uint16_t phy_h = rows;
            uint16_t phy_x = 0;
            uint16_t phy_y = 0;
            
            
            if ( needsinit == true ) {
              needsinit = false;
              for ( i=0; i<rows; ++i ) {
                for ( j=0; j<cols; ++j ) {
                  if ( i == 0 ) pix[i][j] = NCOLORS - 1;
                  else pix[i][j] = 0;
                }
              }
            }
            
            // First, move all existing heat points up the display and fade
            for ( i=rows-1; i>0; --i ) {
              for ( j=0; j<cols; ++j ) {
                uint8_t n = 0;
                if ( pix[i-1][j] > 0 )
                  n = pix[i-1][j] - 1;
                pix[i][j] = n;
              }
            }
          
            // Heat the bottom row
            for ( j=0; j<cols; ++j ) {
              i = pix[0][j];
              if ( i > 0 ) {
                pix[0][j] = random(NCOLORS-6, NCOLORS-2);
              }
            }

            // Update existing flares
            for ( i=0; i<nflare; ++i ) {
              x = flare[i] & 0xff;
              y = (flare[i] >> 8) & 0xff;
              z = (flare[i] >> 16) & 0xff;
              b = z * 10 / flaredecay + 1;
              for ( k=(y-b); k<(y+b); ++k ) {
                for ( int l=(x-b); l<(x+b); ++l ) {
                  if ( k >=0 && l >= 0 && k < rows && l < cols ) {
                    d = ( flaredecay * sqrt16((x-l)*(x-l) + (y-k)*(y-k)) + 5 ) / 10;
                    n = 0;
                    if ( z > d ) n = z - d;
                    if ( n > pix[k][l] ) { // can only get brighter
                      pix[k][l] = n;
                    }
                  }
                }
              }
              if ( z > 1 ) {
                flare[i] = (flare[i] & 0xffff) | ((z-1)<<16);
              } else {
                // This flare is out
                for ( j=i+1; j<nflare; ++j ) {
                  flare[j-1] = flare[j];
                }
                --nflare;
              }
            }
            // New Flare
            if ( nflare < maxflare && random(1,101) <= flarechance ) {
              x = random(0, cols);
              y = random(0, flarerows);
              z = NCOLORS - 1;
              b = z * 10 / flaredecay + 1;
              flare[nflare++] = (z<<16) | (y<<8) | (x&0xff);
              for ( k=(y-b); k<(y+b); ++k ) {
                for ( int l=(x-b); l<(x+b); ++l ) {
                  if ( k >=0 && l >= 0 && k < rows && l < cols ) {
                    d = ( flaredecay * sqrt16((x-l)*(x-l) + (y-k)*(y-k)) + 5 ) / 10;
                    n = 0;
                    if ( z > d ) n = z - d;
                    if ( n > pix[k][l] ) { // can only get brighter
                      pix[k][l] = n;
                    }
                  }
                }
              }
            }
            // Draw
            if ( colmajor == true ) {
              phy_w = rows;
              phy_h = cols;
            }
            for ( uint16_t row=0; row<rows; ++row ) {
              for ( uint16_t col=0; col<cols; ++col ) {
                if ( colmajor == true ) {
                    phy_x = offsetx + (uint16_t) row;
                    phy_y = offsety + (uint16_t) col;
                } else {
                    phy_x = offsetx + (uint16_t) col;
                    phy_y = offsety + (uint16_t) row;
                }
                if ( matleft == true && zigzag == true ) {
                  if ( ( phy_y & 1 ) == 1 ) {
                    phy_x = phy_w - phy_x - 1;
                  }
                } else if ( matleft == false && zigzag == true ) {
                  if ( ( phy_y & 1 ) == 0 ) {
                    phy_x = phy_w - phy_x - 1;
                  }
                } else if ( matleft == false ) {
                  phy_x = phy_w - phy_x - 1;
                }
                if ( mattop == true && colmajor == true ) {
                  phy_x = phy_w - phy_x - 1;
                } else if (mattop) {
                  phy_y = phy_h - phy_y - 1;
                }
                it[phy_x + phy_y * phy_w] = ESPColor(colors[pix[row][col]]);
              }
            }




  - platform: partition
    name: "Partition Light 1"
    id: partition_light_1
    color_correct: [50%, 50%, 50%]
    segments:
      # Use first 10 LEDs from the light with ID light1
      - id: led_matrix_light
        from: 0
        to: 255
    effects:
      - wled:
          port: 1335
      - addressable_twinkle:
      - addressable_twinkle:
          name: Big Twinkle
          twinkle_probability: 95%
          progress_interval: 4ms
      - addressable_rainbow:
      - addressable_rainbow:
          name: Rainbow Custom
          speed: 60
          width: 100
      - addressable_color_wipe:
      - addressable_color_wipe:
          name: Color Wipe Custom
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_scan:
      - addressable_scan:
          name: Scan Effect Custom 
          move_interval: 1ms
          scan_width: 8
      - addressable_random_twinkle:
      - addressable_random_twinkle:
          name: Random Twinkle Custom 
          twinkle_probability: 65%
          progress_interval: 32ms
      - addressable_fireworks:
      - addressable_fireworks:
          name: Fireworks Custom 
          update_interval: 32ms
          spark_probability: 10%
          use_random_color: false
          fade_out_rate: 120
      - addressable_flicker:
      - addressable_flicker:
          name: Flicker Custom 
          update_interval: 8ms
          intensity: 40%

  - platform: partition
    name: "Partition Light 2"
    color_correct: [50%, 50%, 50%]
    id: partition_light_2
    segments:
      # Use LEDs 11-20 from the light with ID light1
      - id: led_matrix_light
        from: 256
        to: 511
    effects:
      - wled:
          port: 1336
      - addressable_twinkle:
      - addressable_twinkle:
          name: Big Twinkle
          twinkle_probability: 95%
          progress_interval: 4ms
      - addressable_rainbow:
      - addressable_rainbow:
          name: Rainbow Custom
          speed: 60
          width: 100
      - addressable_color_wipe:
      - addressable_color_wipe:
          name: Color Wipe Custom
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_scan:
      - addressable_scan:
          name: Scan Effect Custom 
          move_interval: 1ms
          scan_width: 8
      - addressable_random_twinkle:
      - addressable_random_twinkle:
          name: Random Twinkle Custom 
          twinkle_probability: 65%
          progress_interval: 32ms
      - addressable_fireworks:
      - addressable_fireworks:
          name: Fireworks Custom 
          update_interval: 32ms
          spark_probability: 10%
          use_random_color: false
          fade_out_rate: 120
      - addressable_flicker:
      - addressable_flicker:
          name: Flicker Custom 
          update_interval: 8ms
          intensity: 40%

  - platform: partition
    name: "Partition Light 3"
    color_correct: [50%, 50%, 50%]
    id: partition_light_3
    segments:
      # Use LEDs 11-20 from the light with ID light1
      - id: led_matrix_light
        from: 200
        to: 255
    effects:
      - wled:
          port: 1338
      - addressable_twinkle:
      - addressable_twinkle:
          name: Big Twinkle
          twinkle_probability: 95%
          progress_interval: 4ms
      - addressable_rainbow:
      - addressable_rainbow:
          name: Rainbow Custom
          speed: 60
          width: 100
      - addressable_color_wipe:
      - addressable_color_wipe:
          name: Color Wipe Custom
          colors:
            - red: 100%
              green: 100%
              blue: 100%
              num_leds: 1
            - red: 0%
              green: 0%
              blue: 0%
              num_leds: 1
          add_led_interval: 100ms
          reverse: false
      - addressable_scan:
      - addressable_scan:
          name: Scan Effect Custom 
          move_interval: 1ms
          scan_width: 8
      - addressable_random_twinkle:
      - addressable_random_twinkle:
          name: Random Twinkle Custom 
          twinkle_probability: 65%
          progress_interval: 32ms
      - addressable_fireworks:
      - addressable_fireworks:
          name: Fireworks Custom 
          update_interval: 32ms
          spark_probability: 10%
          use_random_color: false
          fade_out_rate: 120
      - addressable_flicker:
      - addressable_flicker:
          name: Flicker Custom 
          update_interval: 8ms
          intensity: 40%

sensor:
  - platform: wifi_signal
    name: Wifi signal
    update_interval: 2min
  - platform: uptime
    name: Uptime
    update_interval: 2min

  - platform: homeassistant
    name: Inside Temperature2
    entity_id: sensor.inside_temp
    id: inside_temp2
    on_value_range:
      - above: 74
        then:
          - mqtt.publish:
              topic: proto/proto-3/display
              payload: "its"
          - mqtt.publish:
              topic: proto/proto-3/display2
              payload: "hot"
      - below: 70
        then:
          - mqtt.publish:
              topic: proto/proto-3/display
              payload: "its"
          - mqtt.publish:
              topic: proto/proto-3/display2
              payload: "cold"

#  - platform: homeassistant
#    name: ha_water_power
#    entity_id: sensor.water_pump_power
#    id: ha_water_power
#  - platform: homeassistant
#    name: ha_phone_battery
#    entity_id: sensor.zack_s_phone_battery_level
#    id: ha_phone_battery
#  - platform: homeassistant
#    name: ha_hot_air
#    entity_id: sensor.shellymotion2_8cf681a1fa80_temperature
#    id: ha_hot_air


text_sensor:
  - platform: version
    name: ESP Version
  - platform: wifi_info
    ssid:
      name: WiFi
      update_interval: 2min
  - platform: wifi_info
    ip_address:
      name: IP Address
  - platform: homeassistant
    name: Inside Temperature
    entity_id: sensor.inside_temp
    id: inside_temp

#  - platform: homeassistant
#    name: test_ha
#    entity_id: sensor.shellymotion2_8cf681a1fa80_temperature
#    id: test_ha

  - platform: mqtt_subscribe
    name: "Proto-4 Wifi Signal"
    id: proto_4_signal
    topic: proto/proto-4/sensor/wifi_signal/state

  - platform: mqtt_subscribe
    name: "Text for Display"
    id: text_for_display
    topic: proto/proto-3/display
    on_value:
        then:
        - display.page.show: page2
        - component.update: led_matrix_32x16_display

  - platform: mqtt_subscribe
    name: "Text for Display 2"
    id: text_for_display2
    topic: proto/proto-3/display2
    on_value:
        then:
        - display.page.show: page2
        - component.update: led_matrix_32x16_display

  - platform: mqtt_subscribe
    name: "Text Display Off"
    id: text_display_off
    topic: proto/proto-3/display-text-off
    on_value:
        then:
        - display.page.show: page1
        - component.update: led_matrix_32x16_display

  - platform: homeassistant
    name: Outside Temperature
    entity_id: sensor.outside_temperature
    id: outside_temp

binary_sensor:
  - platform: homeassistant
    id: little_ac
    entity_id: binary_sensor.little_ac
    on_press:
      then:
        - component.update: led_matrix_32x16_display
    on_release:
        then:
        - component.update: led_matrix_32x16_display
  - platform: homeassistant
    id: big_ac
    entity_id: binary_sensor.big_ac
    on_press:
      then:
        - component.update: led_matrix_32x16_display
    on_release:
        then:
        - component.update: led_matrix_32x16_display


switch:      
  - platform: restart
    name: Restart

#esp32_camera:
#  name: Camera
# external_clock:
#    pin: GPIO0
#    frequency: 15MHz
#  i2c_pins:
#    sda: GPIO26
#    scl: GPIO27
#  data_pins: [GPIO5, GPIO18, GPIO19, GPIO21, GPIO36, GPIO39, GPIO34, GPIO35]
#  vsync_pin: GPIO25
#  href_pin: GPIO23
#  pixel_clock_pin: GPIO22
#  power_down_pin: GPIO32
#  
# Image/Video settings, https://esphome.io/components/esp32_camera.html
#  max_framerate: 1 fps 
#  idle_framerate: 0.1 fps # default: 0.1 fps - framerate for 'picture' in HA dashboard
#  resolution: 320x240
#  jpeg_quality: 10
#  vertical_flip: False
#  contrast: 0 # default: 0, variable -2 to 2
#  brightness: 0 # default: 0, variable -2 to 2
#  saturation: 0 # default: 0, variable -2 to 2
  
#Server video/pictures, https://esphome.io/components/esp32_camera_web_server.html

#esp32_camera_web_server:
#  - port: 8080
#    mode: stream
#  - port: 8081
#    mode: snapshot
